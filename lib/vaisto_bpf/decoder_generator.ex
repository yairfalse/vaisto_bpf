defmodule VaistoBpf.DecoderGenerator do
  @moduledoc """
  Auto-generates BEAM-side binary decoders from BPF record types.

  For each record type, generates `decode_<name>/1` and `encode_<name>/1`
  functions that handle C-aligned binary layout including padding.

  Output is Elixir source code as a string, suitable for writing to a file
  or compiling with `Code.compile_string/1`.
  """

  alias VaistoBpf.Layout

  @doc """
  Generate decoder/encoder source code for a record type.

  Takes a record type name and fields `[{field, type}]`, returns
  Elixir source code string for a decoder module.
  """
  @spec generate(atom(), [{atom(), atom()}]) :: String.t()
  def generate(name, fields) do
    layout = Layout.calculate_layout(fields)
    decode_fn = generate_decode(name, fields, layout)
    encode_fn = generate_encode(name, fields, layout)

    module_name = Atom.to_string(name)

    """
    defmodule #{module_name}.Decoder do
      @moduledoc "Auto-generated by vaisto_bpf â€” do not edit"

    #{decode_fn}
    #{encode_fn}
    end
    """
  end

  # ============================================================================
  # Source Code Generation
  # ============================================================================

  defp generate_decode(name, fields, layout) do
    segments = build_binary_segments(fields, layout, :decode)
    field_names = Enum.map(fields, fn {fname, _type} -> Atom.to_string(fname) end)
    result_tuple = "{:#{name}, #{Enum.join(field_names, ", ")}}"

    fn_name = "decode_#{Macro.underscore(Atom.to_string(name))}"

    """
      def #{fn_name}(<<#{Enum.join(segments, ", ")}>>) do
        #{result_tuple}
      end
    """
  end

  defp generate_encode(name, fields, layout) do
    field_names = Enum.map(fields, fn {fname, _type} -> Atom.to_string(fname) end)
    pattern = "{:#{name}, #{Enum.join(field_names, ", ")}}"
    segments = build_binary_segments(fields, layout, :encode)

    fn_name = "encode_#{Macro.underscore(Atom.to_string(name))}"

    """
      def #{fn_name}(#{pattern}) do
        <<#{Enum.join(segments, ", ")}>>
      end
    """
  end

  # ============================================================================
  # Binary Segment Building
  # ============================================================================

  defp build_binary_segments(fields, layout, mode) do
    field_layouts = layout.fields

    {segments, pad_counter, final_offset} =
      Enum.reduce(Enum.zip(fields, field_layouts), {[], 0, 0},
        fn {{fname, type}, %{offset: offset, size: size}}, {segs, pad_idx, cur_offset} ->
          padding = offset - cur_offset

          {segs, pad_idx} =
            if padding > 0 do
              {segs ++ [pad_segment(pad_idx, padding, mode)], pad_idx + 1}
            else
              {segs, pad_idx}
            end

          field_seg = field_segment(Atom.to_string(fname), type, mode)
          {segs ++ [field_seg], pad_idx, offset + size}
        end)

    # Add tail padding if needed
    tail_pad = layout.total_size - final_offset

    if tail_pad > 0 do
      segments ++ [pad_segment(pad_counter, tail_pad, mode)]
    else
      segments
    end
  end

  defp field_segment(name, type, _mode) do
    bits = Layout.sizeof(type) * 8
    sign = if signed?(type), do: "signed-", else: "unsigned-"
    "#{name}::native-#{sign}integer-#{bits}"
  end

  defp pad_segment(idx, size, :decode) do
    "_pad#{idx}::binary-size(#{size})"
  end

  defp pad_segment(_idx, size, :encode) do
    "0::size(#{size * 8})"
  end

  defp signed?(:i8), do: true
  defp signed?(:i16), do: true
  defp signed?(:i32), do: true
  defp signed?(:i64), do: true
  defp signed?(_), do: false
end
